import { setContext, tick } from 'svelte';
import { derived } from 'svelte/store';
import { Clock, Scene } from 'three';
import { createDefaultCamera } from './defaultCamera';
import { currentWritable } from './storeUtils';
/**
 * ### `createContexts`
 *
 * This function creates the context objects `ThrelteContext` and
 * `ThrelteInternalContext` for a Threlte application.
 */
export const createContexts = (options) => {
    const internalCtx = {
        debugFrameloop: options.debugFrameloop,
        frame: 0,
        frameInvalidated: true,
        invalidations: {},
        manualFrameHandlers: new Set(),
        autoFrameHandlers: new Set(),
        allFrameHandlers: new Set(),
        allFrameHandlersNeedSortCheck: false,
        renderHandlers: new Set(),
        renderHandlersNeedSortCheck: false,
        advance: false,
        dispose: async (force = false) => {
            await tick();
            if (!internalCtx.shouldDispose && !force)
                return;
            internalCtx.disposableObjects.forEach((mounted, object) => {
                if (mounted === 0 || force) {
                    object?.dispose?.();
                    internalCtx.disposableObjects.delete(object);
                }
            });
            internalCtx.shouldDispose = false;
        },
        collectDisposableObjects: (object, objects) => {
            const disposables = objects ?? [];
            if (!object)
                return disposables;
            // Scenes can't be disposed
            if (object?.dispose && typeof object.dispose === 'function' && object.type !== 'Scene') {
                disposables.push(object);
            }
            // iterate over properties of object
            Object.entries(object).forEach(([propKey, propValue]) => {
                // we don't want to dispose the parent, we can skip "children"
                if (propKey === 'parent' || propKey === 'children' || typeof propValue !== 'object')
                    return;
                const value = propValue;
                if (value?.dispose) {
                    internalCtx.collectDisposableObjects(value, disposables);
                }
            });
            return disposables;
        },
        addDisposableObjects: (objects) => {
            objects.forEach((obj) => {
                const currentValue = internalCtx.disposableObjects.get(obj);
                if (currentValue) {
                    internalCtx.disposableObjects.set(obj, currentValue + 1);
                }
                else {
                    internalCtx.disposableObjects.set(obj, 1);
                }
            });
        },
        removeDisposableObjects: (objects) => {
            if (objects.length === 0)
                return;
            objects.forEach((obj) => {
                const currentValue = internalCtx.disposableObjects.get(obj);
                if (currentValue && currentValue > 0) {
                    internalCtx.disposableObjects.set(obj, currentValue - 1);
                }
            });
            internalCtx.shouldDispose = true;
        },
        disposableObjects: new Map(),
        shouldDispose: false
    };
    const ctx = {
        size: derived([options.userSize, options.parentSize], ([uSize, pSize]) => {
            return uSize ? uSize : pSize;
        }),
        clock: new Clock(),
        camera: currentWritable(createDefaultCamera()),
        scene: new Scene(),
        renderer: undefined,
        invalidate: (debugFrameloopMessage) => {
            internalCtx.frameInvalidated = true;
            if (internalCtx.debugFrameloop && debugFrameloopMessage) {
                internalCtx.invalidations[debugFrameloopMessage] = internalCtx.invalidations[debugFrameloopMessage]
                    ? internalCtx.invalidations[debugFrameloopMessage] + 1
                    : 1;
            }
        },
        advance: () => {
            internalCtx.advance = true;
        },
        colorSpace: currentWritable(options.colorSpace),
        toneMapping: currentWritable(options.toneMapping),
        dpr: currentWritable(options.dpr),
        useLegacyLights: currentWritable(options.useLegacyLights),
        shadows: currentWritable(options.shadows),
        colorManagementEnabled: currentWritable(options.colorManagementEnabled),
        frameloop: currentWritable(options.frameloop)
    };
    const userCtx = currentWritable({});
    setContext('threlte', ctx);
    setContext('threlte-internal-context', internalCtx);
    setContext('threlte-user-context', userCtx);
    const getCtx = () => ctx;
    const getInternalCtx = () => internalCtx;
    return {
        ctx,
        internalCtx,
        getCtx,
        getInternalCtx
    };
};
