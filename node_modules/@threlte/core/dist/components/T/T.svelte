<script>import { getContext, setContext } from 'svelte';
import { writable } from 'svelte/store';
import DisposableObject from '../../internal/DisposableObject.svelte';
import SceneGraphObject from '../../internal/SceneGraphObject.svelte';
import { useAttach } from './utils/useAttach';
import { useCamera } from './utils/useCamera';
import { useCreateEvent } from './utils/useCreateEvent';
import { useEvents } from './utils/useEvents';
import { usePlugins } from './utils/usePlugins';
import { useProps } from './utils/useProps';
export let is;
export let args = undefined;
export let attach = undefined;
export let manual = undefined;
export let makeDefault = undefined;
export let dispose = undefined;
const parent = getContext('threlte-hierarchical-parent-context');
// Type Gaurds
const isClass = (type) => {
    return typeof type === 'function' && /^\s*class\s+/.test(type.toString());
};
const argsIsConstructorParameters = (args) => {
    return Array.isArray(args);
};
// Create Event
const createEvent = useCreateEvent();
// We can't create the object in a reactive statement due to providing context
let ref = (isClass(is) && argsIsConstructorParameters(args)
    ? new is(...args) // TODO: fix this any
    : isClass(is)
        ? new is()
        : is);
// The ref is created, emit the event
createEvent.updateRef(ref);
let initialized = false;
// When "is" or "args" change, we need to create a new ref.
const maybeSetRef = () => {
    // Because reactive statements run immediately, we need to ignore the first run.
    if (!initialized) {
        initialized = true;
        return;
    }
    ref = (isClass(is) && argsIsConstructorParameters(args)
        ? new is(...args) // TODO: fix this any
        : isClass(is)
            ? new is()
            : is);
    // The ref is recreated, emit the event
    createEvent.updateRef(ref);
};
$: is, args, maybeSetRef();
// In order to prevent updates by outside mutations on ref,
// we need to create a publicly exposed ref.
let publicRef = ref;
$: publicRef = ref;
export { publicRef as ref };
const refStore = writable(ref);
$: refStore.set(ref);
setContext('threlte-hierarchical-parent-context', refStore);
// Plugins are initialized here so that pluginsProps
// is available in the props update
const plugins = usePlugins({ ref: ref, props: $$props });
const pluginsProps = plugins?.pluginsProps ?? [];
// Props
const props = useProps();
$: props.updateProps(ref, $$restProps, {
    manualCamera: manual,
    pluginsProps
});
// Camera
const camera = useCamera();
$: camera.update(ref, manual);
$: camera.makeDefaultCamera(ref, makeDefault);
// Attachment
const attachment = useAttach();
$: attachment.update(ref, $parent, attach);
// Events
const events = useEvents();
$: events.updateRef(ref);
// update plugins after all other updates
$: plugins?.updateRef(ref);
$: plugins?.updateProps($$props);
$: plugins?.updateRestProps($$restProps);
const extendsObject3D = (object) => {
    return !!object.isObject3D;
};
const isDisposableObject = (object) => {
    return object.dispose !== undefined;
};
</script>

{#if isDisposableObject(ref)}
  <DisposableObject
    object={ref}
    {dispose}
  />
{/if}

{#if extendsObject3D(ref)}
  <SceneGraphObject object={ref}>
    <slot {ref} />
  </SceneGraphObject>
{:else}
  <slot {ref} />
{/if}
