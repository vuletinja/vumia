import type { Loader as ThreeLoader } from 'three';
import { type AsyncWritable } from '../lib/asyncWritable';
export interface Loader extends ThreeLoader {
    loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any>;
}
type LoaderProto = {
    new (): Loader;
};
export type UseLoaderLoadInput = string | string[] | Record<string, string>;
type LoaderResultType<TLoader extends Loader> = Awaited<ReturnType<TLoader['loadAsync']>>;
export type UseLoaderLoadResult<TLoader extends Loader, Input extends UseLoaderLoadInput, ResultType = LoaderResultType<TLoader>> = Input extends string ? AsyncWritable<ResultType> : Input extends string[] ? AsyncWritable<ResultType[]> : AsyncWritable<Record<keyof Input, ResultType>>;
type UseLoaderLoadTransform<TLoader extends Loader> = (result: LoaderResultType<TLoader>) => any;
type UseLoaderLoadOptions<TLoader extends Loader> = {
    onProgress?: (event: ProgressEvent) => void;
    transform?: UseLoaderLoadTransform<TLoader>;
};
type ThrelteUseLoader<TLoader extends Loader> = {
    loader: TLoader;
    load: <Input extends UseLoaderLoadInput, Options extends UseLoaderLoadOptions<TLoader> | undefined, ResultType = Options extends UseLoaderLoadOptions<TLoader> ? Options['transform'] extends UseLoaderLoadTransform<TLoader> ? ReturnType<Options['transform']> : LoaderResultType<TLoader> : LoaderResultType<TLoader>>(input: Input, options?: Options) => UseLoaderLoadResult<TLoader, Input, ResultType>;
    clear: <Input extends string | string[] | Record<string, string>>(input: Input) => void;
};
export type UseLoaderOptions<TLoader extends Loader> = {
    /**
     * A loader can be extended to add custom
     * functionality, e.g. add DRACO support.
     */
    extend?: (loader: TLoader) => void;
};
export declare const useLoader: <Proto extends LoaderProto, UseLoaderResult = ThrelteUseLoader<InstanceType<Proto>>>(Proto: Proto, options?: UseLoaderOptions<InstanceType<Proto>>) => UseLoaderResult;
export {};
