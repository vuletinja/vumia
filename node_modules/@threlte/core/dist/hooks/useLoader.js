import { asyncWritable } from '../lib/asyncWritable';
import { useCache } from '../lib/cache';
export const useLoader = (Proto, options = {}) => {
    const { remember, clear: clearCacheItem } = useCache();
    // instantiate the loader
    const loader = new Proto();
    // extend the loader if necessary
    options.extend?.(loader);
    const load = (input, options) => {
        if (Array.isArray(input)) {
            // map over the input array and return an array of promises
            const promises = input.map((url) => {
                return remember(async () => {
                    const result = await loader.loadAsync(url, options?.onProgress);
                    return options?.transform?.(result) ?? result;
                }, [Proto, url]);
            });
            // return an AsyncWritable that resolves to the array of promises
            const store = asyncWritable(Promise.all(promises));
            return store; // TODO: Dirty escape hatch
        }
        else if (typeof input === 'string') {
            // debugger
            const promise = remember(async () => {
                const result = await loader.loadAsync(input, options?.onProgress);
                return options?.transform?.(result) ?? result;
            }, [Proto, input]);
            // return an AsyncWritable that resolves to the promise
            const store = asyncWritable(promise);
            return store; // TODO: Dirty escape hatch
        }
        else {
            // map over the input object and return an array of promises
            const promises = Object.values(input).map((url) => {
                return remember(async () => {
                    const result = await loader.loadAsync(url, options?.onProgress);
                    return options?.transform?.(result) ?? result;
                }, [Proto, url]);
            });
            // return an AsyncWritable that resolves to the object of promises
            const store = asyncWritable(Promise.all(promises).then((results) => {
                return Object.fromEntries(Object.entries(input).map(([key], i) => [key, results[i]]));
            }));
            return store; // TODO: Dirty escape hatch
        }
    };
    const clear = (input) => {
        if (Array.isArray(input)) {
            input.forEach((url) => {
                clearCacheItem([Proto, url]);
            });
        }
        else if (typeof input === 'string') {
            clearCacheItem([Proto, input]);
        }
        else {
            Object.entries(input).forEach(([key, url]) => {
                clearCacheItem([Proto, key, url]);
            });
        }
    };
    return {
        load,
        clear,
        loader
    };
};
