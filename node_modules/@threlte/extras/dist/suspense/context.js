import { createRawEventDispatcher, currentWritable } from '@threlte/core';
import { setContext } from 'svelte';
import { derived, writable } from 'svelte/store';
export const suspenseContextIdentifier = Symbol('THRELTE_SUSPENSE_CONTEXT_IDENTIFIER');
export const createSuspenseContext = (options) => {
    const dispatch = createRawEventDispatcher();
    /**
     * This map contains all the promises that are currently being suspended.
     */
    const promises = currentWritable(new Map());
    /**
     * This map contains all the errors that were thrown during the suspension.
     */
    const errors = currentWritable(new Map());
    const finalized = writable(false);
    const checkFinalized = () => {
        if (promises.current.size === 0 && errors.current.size === 0)
            finalized.set(true);
    };
    const finalStore = writable(options?.final ?? false);
    const addPromise = (component, promise) => {
        promises.update((map) => {
            if (map.has(component)) {
                map.get(component)?.add(promise);
            }
            else {
                map.set(component, new Set([promise]));
            }
            return map;
        });
    };
    const removePromise = (component, promise) => {
        promises.update((map) => {
            if (map.has(component)) {
                map.get(component)?.delete(promise);
            }
            if (map.get(component)?.size === 0) {
                map.delete(component);
            }
            return map;
        });
    };
    const addError = (component, error) => {
        errors.update((map) => {
            if (map.has(component)) {
                map.get(component)?.push(error);
            }
            else {
                map.set(component, [error]);
            }
            return map;
        });
    };
    /**
     * A Suspense component is suspending its children if it has any pending
     * promises or errors.
     * "suspended" means that the default slot is not rendered.
     * If the final prop is set to true, the Suspense component will not
     * suspend its children once all promises are resolved and all errors are
     * handled.
     */
    const suspended = derived([promises, errors, finalStore, finalized], ([promises, errors, final, finalized]) => {
        if (final && finalized) {
            // if the suspense settled *once*, it will never suspend again.
            return false;
        }
        else if (errors.size > 0) {
            // suspense if there are errors
            return true;
        }
        else {
            // suspense if there are pending promises
            return promises.size > 0;
        }
    });
    const context = {
        suspend(component, promise) {
            addPromise(component, promise);
            promise
                .then(() => {
                if (promises.current.get(component)?.has(promise)) {
                    removePromise(component, promise);
                }
            })
                .catch((error) => {
                if (promises.current.get(component)?.has(promise)) {
                    removePromise(component, promise);
                    addError(component, error);
                    dispatch('error', error);
                }
            })
                .finally(() => {
                checkFinalized();
            });
        },
        onComponentDestroy(component) {
            promises.update((map) => {
                map.delete(component);
                return map;
            });
            errors.update((map) => {
                map.delete(component);
                return map;
            });
            checkFinalized();
        },
        suspended
    };
    const errorsArray = derived(errors, (errors) => Array.from(errors.values()).flat());
    setContext(suspenseContextIdentifier, context);
    return {
        promises,
        suspended,
        errors: errorsArray,
        setFinal: (final) => finalStore.set(final ?? false)
    };
};
