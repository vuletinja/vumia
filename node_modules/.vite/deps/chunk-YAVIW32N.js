import {
  ACESFilmicToneMapping,
  Clock,
  ColorManagement,
  LinearEncoding,
  PCFSoftShadowMap,
  PerspectiveCamera,
  REVISION,
  Scene,
  WebGLRenderer,
  sRGBEncoding,
  three_module_exports
} from "./chunk-4J75DYDB.js";
import {
  derived,
  readable,
  writable
} from "./chunk-RDFSMRK3.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  compute_rest_props,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_store_value,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  onDestroy,
  onMount,
  safe_not_equal,
  setContext,
  space,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-ICOQBKZO.js";

// node_modules/@threlte/core/dist/hooks/useThrelteInternal.js
var useThrelteInternal = () => {
  return getContext("threlte-internal-context");
};

// node_modules/@threlte/core/dist/internal/DisposableObject.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var contextName = "threlte-disposable-object-context";
function instance($$self, $$props, $$invalidate) {
  let $mergedDispose;
  let $parentDispose;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DisposableObject", slots, ["default"]);
  const { collectDisposableObjects, addDisposableObjects, removeDisposableObjects } = useThrelteInternal();
  let { object = void 0 } = $$props;
  let previousObject = object;
  let { dispose = void 0 } = $$props;
  const parentDispose = getContext(contextName);
  validate_store(parentDispose, "parentDispose");
  component_subscribe($$self, parentDispose, (value) => $$invalidate(7, $parentDispose = value));
  const mergedDispose = writable(dispose ?? $parentDispose ?? true);
  validate_store(mergedDispose, "mergedDispose");
  component_subscribe($$self, mergedDispose, (value) => $$invalidate(6, $mergedDispose = value));
  setContext(contextName, mergedDispose);
  let disposables = $mergedDispose ? collectDisposableObjects(object) : [];
  addDisposableObjects(disposables);
  onDestroy(() => {
    removeDisposableObjects(disposables);
  });
  const writable_props = ["object", "dispose"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DisposableObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
    if ("dispose" in $$props2)
      $$invalidate(3, dispose = $$props2.dispose);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onDestroy,
    setContext,
    writable,
    useThrelteInternal,
    collectDisposableObjects,
    addDisposableObjects,
    removeDisposableObjects,
    object,
    previousObject,
    dispose,
    contextName,
    parentDispose,
    mergedDispose,
    disposables,
    $mergedDispose,
    $parentDispose
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
    if ("previousObject" in $$props2)
      $$invalidate(4, previousObject = $$props2.previousObject);
    if ("dispose" in $$props2)
      $$invalidate(3, dispose = $$props2.dispose);
    if ("disposables" in $$props2)
      $$invalidate(5, disposables = $$props2.disposables);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dispose, $parentDispose*/
    136) {
      $:
        mergedDispose.set(dispose ?? $parentDispose ?? true);
    }
    if ($$self.$$.dirty & /*object, previousObject, disposables, $mergedDispose*/
    116) {
      $: {
        if (object !== previousObject) {
          removeDisposableObjects(disposables);
          $$invalidate(5, disposables = $mergedDispose ? collectDisposableObjects(object) : []);
          addDisposableObjects(disposables);
          $$invalidate(4, previousObject = object);
        }
      }
    }
  };
  return [
    parentDispose,
    mergedDispose,
    object,
    dispose,
    previousObject,
    disposables,
    $mergedDispose,
    $parentDispose,
    $$scope,
    slots
  ];
}
var DisposableObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { object: 2, dispose: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DisposableObject",
      options,
      id: create_fragment.name
    });
  }
  get object() {
    throw new Error("<DisposableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<DisposableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<DisposableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<DisposableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DisposableObject_default = DisposableObject;

// node_modules/@threlte/core/dist/lib/createObjectStore.js
function createObjectStore(object, onChange) {
  const objectStore = writable(object);
  let unwrappedObject = object;
  const unsubscribeObjectStore = objectStore.subscribe((o) => unwrappedObject = o);
  onDestroy(unsubscribeObjectStore);
  const set = (newObject) => {
    if ((newObject == null ? void 0 : newObject.uuid) === (unwrappedObject == null ? void 0 : unwrappedObject.uuid))
      return;
    const oldObject = unwrappedObject;
    objectStore.set(newObject);
    onChange == null ? void 0 : onChange(newObject, oldObject);
  };
  const update = (callback) => {
    const newObject = callback(unwrappedObject);
    if ((newObject == null ? void 0 : newObject.uuid) === (unwrappedObject == null ? void 0 : unwrappedObject.uuid))
      return;
    const oldObject = unwrappedObject;
    objectStore.set(newObject);
    onChange == null ? void 0 : onChange(newObject, oldObject);
  };
  return {
    ...objectStore,
    set,
    update
  };
}

// node_modules/@threlte/core/dist/hooks/useThrelte.js
var useThrelte = () => {
  const context = getContext("threlte");
  if (context === void 0) {
    throw new Error("No Threlte context found, are you using this hook inside of <Canvas>?");
  }
  return context;
};

// node_modules/@threlte/core/dist/hooks/useParent.js
var useParent = () => {
  return getContext("threlte-hierarchical-parent-context");
};

// node_modules/@threlte/core/dist/internal/HierarchicalObject.svelte
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var useHierarchicalObject = () => {
  return {
    onChildMount: getContext("threlte-hierarchical-object-on-mount"),
    onChildDestroy: getContext("threlte-hierarchical-object-on-destroy")
  };
};
function instance2($$self, $$props, $$invalidate) {
  var _a;
  let $parentStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HierarchicalObject", slots, ["default"]);
  let { object = void 0 } = $$props;
  let { children: children2 = [] } = $$props;
  let { onChildMount = void 0 } = $$props;
  const onChildMountProxy = (child) => {
    children2.push(child);
    $$invalidate(1, children2);
    onChildMount == null ? void 0 : onChildMount(child);
  };
  let { onChildDestroy = void 0 } = $$props;
  const onChildDestroyProxy = (child) => {
    const index = children2.findIndex((c) => c.uuid === child.uuid);
    if (index !== -1)
      children2.splice(index, 1);
    $$invalidate(1, children2);
    onChildDestroy == null ? void 0 : onChildDestroy(child);
  };
  const { invalidate } = useThrelte();
  const parentStore = useParent();
  validate_store(parentStore, "parentStore");
  component_subscribe($$self, parentStore, (value) => $$invalidate(6, $parentStore = value));
  let { parent = $parentStore } = $$props;
  const parentCallbacks = useHierarchicalObject();
  if (object) {
    (_a = parentCallbacks.onChildMount) == null ? void 0 : _a.call(parentCallbacks, object);
    invalidate("HierarchicalObject: object added");
  }
  const objectStore = createObjectStore(object, (newObject, oldObject) => {
    var _a2, _b;
    if (oldObject) {
      (_a2 = parentCallbacks.onChildDestroy) == null ? void 0 : _a2.call(parentCallbacks, oldObject);
      invalidate("HierarchicalObject: object added");
    }
    if (newObject) {
      (_b = parentCallbacks.onChildMount) == null ? void 0 : _b.call(parentCallbacks, newObject);
      invalidate("HierarchicalObject: object removed");
    }
  });
  onDestroy(() => {
    var _a2;
    if (object) {
      (_a2 = parentCallbacks.onChildDestroy) == null ? void 0 : _a2.call(parentCallbacks, object);
      invalidate("HierarchicalObject: object removed");
    }
  });
  setContext("threlte-hierarchical-object-on-mount", onChildMountProxy);
  setContext("threlte-hierarchical-object-on-destroy", onChildDestroyProxy);
  setContext("threlte-hierarchical-parent-context", objectStore);
  const writable_props = ["object", "children", "onChildMount", "onChildDestroy", "parent"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HierarchicalObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(3, object = $$props2.object);
    if ("children" in $$props2)
      $$invalidate(1, children2 = $$props2.children);
    if ("onChildMount" in $$props2)
      $$invalidate(4, onChildMount = $$props2.onChildMount);
    if ("onChildDestroy" in $$props2)
      $$invalidate(5, onChildDestroy = $$props2.onChildDestroy);
    if ("parent" in $$props2)
      $$invalidate(2, parent = $$props2.parent);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onDestroy,
    setContext,
    useParent,
    useThrelte,
    createObjectStore,
    useHierarchicalObject,
    object,
    children: children2,
    onChildMount,
    onChildMountProxy,
    onChildDestroy,
    onChildDestroyProxy,
    invalidate,
    parentStore,
    parent,
    parentCallbacks,
    objectStore,
    $parentStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(3, object = $$props2.object);
    if ("children" in $$props2)
      $$invalidate(1, children2 = $$props2.children);
    if ("onChildMount" in $$props2)
      $$invalidate(4, onChildMount = $$props2.onChildMount);
    if ("onChildDestroy" in $$props2)
      $$invalidate(5, onChildDestroy = $$props2.onChildDestroy);
    if ("parent" in $$props2)
      $$invalidate(2, parent = $$props2.parent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$parentStore*/
    64) {
      $:
        $$invalidate(2, parent = $parentStore);
    }
    if ($$self.$$.dirty & /*object*/
    8) {
      $:
        objectStore.set(object);
    }
  };
  return [
    parentStore,
    children2,
    parent,
    object,
    onChildMount,
    onChildDestroy,
    $parentStore,
    $$scope,
    slots
  ];
}
var HierarchicalObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      object: 3,
      children: 1,
      onChildMount: 4,
      onChildDestroy: 5,
      parent: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HierarchicalObject",
      options,
      id: create_fragment2.name
    });
  }
  get object() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChildMount() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChildMount(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChildDestroy() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChildDestroy(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parent() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parent(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HierarchicalObject_default = HierarchicalObject;

// node_modules/@threlte/core/dist/internal/SceneGraphObject.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(5:0) <HierarchicalObject   {object}   onChildMount={(child) => object.add(child)}   onChildDestroy={(child) => object.remove(child)} >",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let hierarchicalobject;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: {
      object: (
        /*object*/
        ctx[0]
      ),
      onChildMount: (
        /*func*/
        ctx[2]
      ),
      onChildDestroy: (
        /*func_1*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hierarchicalobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hierarchicalobject_changes = {};
      if (dirty & /*object*/
      1)
        hierarchicalobject_changes.object = /*object*/
        ctx2[0];
      if (dirty & /*object*/
      1)
        hierarchicalobject_changes.onChildMount = /*func*/
        ctx2[2];
      if (dirty & /*object*/
      1)
        hierarchicalobject_changes.onChildDestroy = /*func_1*/
        ctx2[3];
      if (dirty & /*$$scope*/
      16) {
        hierarchicalobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hierarchicalobject.$set(hierarchicalobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hierarchicalobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hierarchicalobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SceneGraphObject", slots, ["default"]);
  let { object } = $$props;
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<SceneGraphObject> was created without expected prop 'object'");
    }
  });
  const writable_props = ["object"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SceneGraphObject> was created with unknown prop '${key}'`);
  });
  const func = (child) => object.add(child);
  const func_1 = (child) => object.remove(child);
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(0, object = $$props2.object);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ HierarchicalObject: HierarchicalObject_default, object });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(0, object = $$props2.object);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [object, slots, func, func_1, $$scope];
}
var SceneGraphObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { object: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SceneGraphObject",
      options,
      id: create_fragment3.name
    });
  }
  get object() {
    throw new Error("<SceneGraphObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<SceneGraphObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SceneGraphObject_default = SceneGraphObject;

// node_modules/@threlte/core/dist/components/T/utils/resolvePropertyPath.js
var resolvePropertyPath = (target, propertyPath) => {
  if (propertyPath.includes(".")) {
    const path = propertyPath.split(".");
    const key = path.pop();
    for (let i = 0; i < path.length; i += 1) {
      target = target[path[i]];
    }
    return {
      target,
      key
    };
  } else {
    return {
      target,
      key: propertyPath
    };
  }
};

// node_modules/@threlte/core/dist/components/T/utils/useAttach.js
var initialValueBeforeAttach = Symbol("initialValueBeforeAttach");
var useAttach = () => {
  const { invalidate } = useThrelte();
  let isAttached = false;
  let valueBeforeAttach = initialValueBeforeAttach;
  let detachFn;
  let attachedTo;
  let attachedKey;
  const update = (instance6, parent, attach) => {
    detach();
    if (!attach) {
      const i = instance6;
      const isMaterial = (i == null ? void 0 : i.isMaterial) || false;
      if (isMaterial) {
        attach = "material";
      }
      const isGeometry = (i == null ? void 0 : i.isBufferGeometry) || (i == null ? void 0 : i.isGeometry) || false;
      if (isGeometry) {
        attach = "geometry";
      }
    }
    if (!attach)
      return;
    if (typeof attach === "function") {
      detachFn = attach(parent, instance6);
    } else {
      const { target, key } = resolvePropertyPath(parent, attach);
      valueBeforeAttach = target[key];
      target[key] = instance6;
      attachedTo = target;
      attachedKey = key;
    }
    isAttached = true;
    invalidate();
  };
  const detach = () => {
    if (!isAttached)
      return;
    if (detachFn) {
      detachFn();
      detachFn = void 0;
    } else if (attachedTo && attachedKey && valueBeforeAttach !== initialValueBeforeAttach) {
      attachedTo[attachedKey] = valueBeforeAttach;
      valueBeforeAttach = initialValueBeforeAttach;
      attachedTo = void 0;
      attachedKey = void 0;
    }
    isAttached = false;
    invalidate();
  };
  onDestroy(() => {
    detach();
  });
  return {
    update
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useCamera.js
var isCamera = (value) => {
  return value && value.isCamera;
};
var isOrthographicCamera = (value) => {
  return value && value.isOrthographicCamera;
};
var isPerspectiveCamera = (value) => {
  return value && value.isPerspectiveCamera;
};
var isPerspectiveCameraOrOrthographicCamera = (value) => {
  return isPerspectiveCamera(value) || isOrthographicCamera(value);
};
var useCamera = () => {
  const { invalidate, size, camera } = useThrelte();
  let currentInstance;
  let unsubscribe = void 0;
  onDestroy(() => {
    unsubscribe == null ? void 0 : unsubscribe();
  });
  const subscriber = (size2) => {
    if (!currentInstance)
      return;
    if (isOrthographicCamera(currentInstance)) {
      currentInstance.left = size2.width / -2;
      currentInstance.right = size2.width / 2;
      currentInstance.top = size2.height / 2;
      currentInstance.bottom = size2.height / -2;
      currentInstance.updateProjectionMatrix();
      currentInstance.updateMatrixWorld();
      invalidate();
    } else if (isPerspectiveCamera(currentInstance)) {
      currentInstance.aspect = size2.width / size2.height;
      currentInstance.updateProjectionMatrix();
      currentInstance.updateMatrixWorld();
      invalidate();
    }
  };
  const update = (instance6, manual) => {
    unsubscribe == null ? void 0 : unsubscribe();
    if (manual || !isPerspectiveCameraOrOrthographicCamera(instance6)) {
      currentInstance = void 0;
      return;
    }
    currentInstance = instance6;
    unsubscribe = size.subscribe(subscriber);
  };
  const makeDefaultCamera = (instance6, makeDefault) => {
    if (!isCamera(instance6) || !makeDefault)
      return;
    camera.set(instance6);
    invalidate();
  };
  return {
    update,
    makeDefaultCamera
  };
};

// node_modules/@threlte/core/dist/lib/createRawEventDispatcher.js
var createRawEventDispatcher = () => {
  const component = get_current_component();
  const dispatchRawEvent = (type, value) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      callbacks.forEach((fn) => {
        fn(value);
      });
    }
  };
  const hasEventListener = (type) => {
    return Boolean(component.$$.callbacks[type]);
  };
  Object.defineProperty(dispatchRawEvent, "hasEventListener", {
    value: hasEventListener,
    enumerable: true
  });
  return dispatchRawEvent;
};

// node_modules/@threlte/core/dist/components/T/utils/useCreateEvent.js
var useCreateEvent = () => {
  const dispatchRaw = createRawEventDispatcher();
  const cleanupFunctions = [];
  let ref = void 0;
  let mounted = false;
  const dispatchCreateEvent = () => {
    cleanupFunctions.forEach((cleanup2) => cleanup2());
    cleanupFunctions.length = 0;
    const cleanup = (callback) => {
      cleanupFunctions.push(callback);
    };
    dispatchRaw("create", { ref, cleanup });
  };
  const updateRef = (newRef) => {
    ref = newRef;
    if (!mounted)
      return;
    dispatchCreateEvent();
  };
  onMount(() => {
    dispatchCreateEvent();
    mounted = true;
  });
  onDestroy(() => {
    cleanupFunctions.forEach((cleanup) => cleanup());
  });
  return {
    updateRef
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useEvents.js
var isEventDispatcher = (value) => {
  return !!(value == null ? void 0 : value.addEventListener);
};
var useEvents = () => {
  const dispatch = createRawEventDispatcher();
  const component = get_current_component();
  const eventHandlerProxy = (event) => {
    if (event == null ? void 0 : event.type) {
      dispatch(event.type, event);
    }
  };
  const cleanupEventListeners = (ref2, events) => {
    if (isEventDispatcher(ref2)) {
      events.forEach((eventName) => {
        ref2.removeEventListener(eventName, eventHandlerProxy);
      });
    }
  };
  const addEventListeners = (ref2, events) => {
    if (isEventDispatcher(ref2)) {
      events.forEach((eventName) => {
        ref2.addEventListener(eventName, eventHandlerProxy);
      });
    }
  };
  let currentEventNames = [];
  let currentRef;
  const eventNames = writable([]);
  const unsubscribeEventNames = eventNames.subscribe((eventNames2) => {
    cleanupEventListeners(currentRef, currentEventNames);
    addEventListeners(currentRef, eventNames2);
    currentEventNames = eventNames2;
  });
  onDestroy(unsubscribeEventNames);
  const ref = writable();
  const unsubscribeRef = ref.subscribe((value) => {
    cleanupEventListeners(currentRef, currentEventNames);
    addEventListeners(value, currentEventNames);
    currentRef = value;
  });
  onDestroy(unsubscribeRef);
  onDestroy(() => {
    cleanupEventListeners(currentRef, currentEventNames);
  });
  onMount(() => {
    eventNames.set(Object.keys(component.$$.callbacks));
  });
  const updateRef = (newRef) => {
    ref.set(newRef);
  };
  return {
    updateRef
  };
};

// node_modules/@threlte/core/dist/components/T/utils/usePlugins.js
var usePlugins = (params) => {
  const pluginContextName = "threlte-plugin-context";
  const plugins = getContext(pluginContextName);
  if (!plugins)
    return;
  const pluginsReturns = Object.values(plugins).map((plugin) => plugin(params)).filter(Boolean);
  const pluginsProps = pluginsReturns.flatMap((callback) => callback.pluginProps ?? []);
  let refCleanupCallbacks = [];
  onDestroy(() => {
    refCleanupCallbacks.forEach((callback) => callback());
  });
  const updateRef = (ref) => {
    refCleanupCallbacks.forEach((callback) => callback());
    refCleanupCallbacks = [];
    pluginsReturns.forEach((callback) => {
      var _a;
      const cleanupCallback = (_a = callback.onRefChange) == null ? void 0 : _a.call(callback, ref);
      if (cleanupCallback) {
        refCleanupCallbacks.push(cleanupCallback);
      }
    });
  };
  const updateProps = (props) => {
    pluginsReturns.forEach((callback) => {
      var _a;
      (_a = callback.onPropsChange) == null ? void 0 : _a.call(callback, props);
    });
  };
  const updateRestProps = (restProps) => {
    pluginsReturns.forEach((callback) => {
      var _a;
      (_a = callback.onRestPropsChange) == null ? void 0 : _a.call(callback, restProps);
    });
  };
  return {
    updateRef,
    updateProps,
    updateRestProps,
    pluginsProps
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useProps.js
var ignoredProps = /* @__PURE__ */ new Set(["$$scope", "$$slots", "type", "args", "attach", "instance"]);
var updateProjectionMatrixKeys = /* @__PURE__ */ new Set([
  "fov",
  "aspect",
  "near",
  "far",
  "left",
  "right",
  "top",
  "bottom",
  "zoom"
]);
var memoizeProp = (value) => {
  if (typeof value === "string")
    return true;
  if (typeof value === "number")
    return true;
  if (typeof value === "boolean")
    return true;
  if (typeof value === "undefined")
    return true;
  if (value === null)
    return true;
  return false;
};
var useProps = () => {
  const { invalidate } = useThrelte();
  const memoizedProps = /* @__PURE__ */ new Map();
  const setProp = (instance6, propertyPath, value, options) => {
    var _a, _b;
    if (memoizeProp(value)) {
      const memoizedProp = memoizedProps.get(propertyPath);
      if (memoizedProp && memoizedProp.instance === instance6 && memoizedProp.value === value) {
        return;
      }
      memoizedProps.set(propertyPath, {
        instance: instance6,
        value
      });
    }
    const { key, target } = resolvePropertyPath(instance6, propertyPath);
    if (!Array.isArray(value) && typeof value === "number" && typeof ((_a = target[key]) == null ? void 0 : _a.setScalar) === "function") {
      target[key].setScalar(value);
    } else {
      if (typeof ((_b = target[key]) == null ? void 0 : _b.set) === "function") {
        if (Array.isArray(value)) {
          target[key].set(...value);
        } else {
          target[key].set(value);
        }
      } else {
        target[key] = value;
        if (options.manualCamera)
          return;
        if (updateProjectionMatrixKeys.has(key) && (target.isPerspectiveCamera || target.isOrthographicCamera)) {
          target.updateProjectionMatrix();
        }
      }
    }
  };
  const updateProps = (instance6, props, options) => {
    var _a;
    for (const key in props) {
      if (!ignoredProps.has(key) && !((_a = options.pluginsProps) == null ? void 0 : _a.includes(key))) {
        setProp(instance6, key, props[key], options);
      }
      invalidate();
    }
  };
  return {
    updateProps
  };
};

// node_modules/@threlte/core/dist/components/T/T.svelte
var get_default_slot_changes_1 = (dirty) => ({ ref: dirty & /*ref*/
2 });
var get_default_slot_context_1 = (ctx) => ({ ref: (
  /*ref*/
  ctx[1]
) });
var get_default_slot_changes = (dirty) => ({ ref: dirty & /*ref*/
2 });
var get_default_slot_context = (ctx) => ({ ref: (
  /*ref*/
  ctx[1]
) });
function create_if_block_1(ctx) {
  let disposableobject;
  let current;
  disposableobject = new DisposableObject_default({
    props: {
      object: (
        /*ref*/
        ctx[1]
      ),
      dispose: (
        /*dispose*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(disposableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(disposableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(disposableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const disposableobject_changes = {};
      if (dirty & /*ref*/
      2)
        disposableobject_changes.object = /*ref*/
        ctx2[1];
      if (dirty & /*dispose*/
      1)
        disposableobject_changes.dispose = /*dispose*/
        ctx2[0];
      disposableobject.$set(disposableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(disposableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(disposableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(disposableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(92:0) {#if isDisposableObject(ref)}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context_1
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        8194)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes_1
            ),
            get_default_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(103:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let scenegraphobject;
  let current;
  scenegraphobject = new SceneGraphObject_default({
    props: {
      object: (
        /*ref*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scenegraphobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scenegraphobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scenegraphobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const scenegraphobject_changes = {};
      if (dirty & /*ref*/
      2)
        scenegraphobject_changes.object = /*ref*/
        ctx2[1];
      if (dirty & /*$$scope, ref*/
      8194) {
        scenegraphobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scenegraphobject.$set(scenegraphobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(scenegraphobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scenegraphobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scenegraphobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(99:0) {#if extendsObject3D(ref)}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        8194)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(100:2) <SceneGraphObject object={ref}>",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let show_if_1 = (
    /*isDisposableObject*/
    ctx[4](
      /*ref*/
      ctx[1]
    )
  );
  let t;
  let show_if;
  let current_block_type_index;
  let if_block1;
  let if_block1_anchor;
  let current;
  let if_block0 = show_if_1 && create_if_block_1(ctx);
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*ref*/
    2)
      show_if = null;
    if (show_if == null)
      show_if = !!/*extendsObject3D*/
      ctx2[3](
        /*ref*/
        ctx2[1]
      );
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*ref*/
      2)
        show_if_1 = /*isDisposableObject*/
        ctx2[4](
          /*ref*/
          ctx2[1]
        );
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*ref*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["is", "args", "attach", "manual", "makeDefault", "dispose", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("T", slots, ["default"]);
  let { is } = $$props;
  let { args = void 0 } = $$props;
  let { attach = void 0 } = $$props;
  let { manual = void 0 } = $$props;
  let { makeDefault = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  const parent = getContext("threlte-hierarchical-parent-context");
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(11, $parent = value));
  const isClass = (type) => {
    return typeof type === "function" && /^\s*class\s+/.test(type.toString());
  };
  const argsIsConstructorParameters = (args2) => {
    return Array.isArray(args2);
  };
  const createEvent = useCreateEvent();
  let ref = isClass(is) && argsIsConstructorParameters(args) ? new is(...args) : isClass(
    is
  ) ? new is() : is;
  createEvent.updateRef(ref);
  let initialized = false;
  const maybeSetRef = () => {
    if (!initialized) {
      initialized = true;
      return;
    }
    $$invalidate(1, ref = isClass(is) && argsIsConstructorParameters(args) ? new is(...args) : isClass(
      is
    ) ? new is() : is);
    createEvent.updateRef(ref);
  };
  let { ref: publicRef = ref } = $$props;
  const refStore = writable(ref);
  setContext("threlte-hierarchical-parent-context", refStore);
  const plugins = usePlugins({ ref, props: $$props });
  const pluginsProps = (plugins == null ? void 0 : plugins.pluginsProps) ?? [];
  const props = useProps();
  const camera = useCamera();
  const attachment = useAttach();
  const events = useEvents();
  const extendsObject3D = (object) => {
    return !!object.isObject3D;
  };
  const isDisposableObject = (object) => {
    return object.dispose !== void 0;
  };
  $$self.$$.on_mount.push(function() {
    if (is === void 0 && !("is" in $$props || $$self.$$.bound[$$self.$$.props["is"]])) {
      console.warn("<T> was created without expected prop 'is'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("is" in $$new_props)
      $$invalidate(6, is = $$new_props.is);
    if ("args" in $$new_props)
      $$invalidate(7, args = $$new_props.args);
    if ("attach" in $$new_props)
      $$invalidate(8, attach = $$new_props.attach);
    if ("manual" in $$new_props)
      $$invalidate(9, manual = $$new_props.manual);
    if ("makeDefault" in $$new_props)
      $$invalidate(10, makeDefault = $$new_props.makeDefault);
    if ("dispose" in $$new_props)
      $$invalidate(0, dispose = $$new_props.dispose);
    if ("ref" in $$new_props)
      $$invalidate(5, publicRef = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    writable,
    DisposableObject: DisposableObject_default,
    SceneGraphObject: SceneGraphObject_default,
    useAttach,
    useCamera,
    useCreateEvent,
    useEvents,
    usePlugins,
    useProps,
    is,
    args,
    attach,
    manual,
    makeDefault,
    dispose,
    parent,
    isClass,
    argsIsConstructorParameters,
    createEvent,
    ref,
    initialized,
    maybeSetRef,
    publicRef,
    refStore,
    plugins,
    pluginsProps,
    props,
    camera,
    attachment,
    events,
    extendsObject3D,
    isDisposableObject,
    $parent
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
    if ("is" in $$props)
      $$invalidate(6, is = $$new_props.is);
    if ("args" in $$props)
      $$invalidate(7, args = $$new_props.args);
    if ("attach" in $$props)
      $$invalidate(8, attach = $$new_props.attach);
    if ("manual" in $$props)
      $$invalidate(9, manual = $$new_props.manual);
    if ("makeDefault" in $$props)
      $$invalidate(10, makeDefault = $$new_props.makeDefault);
    if ("dispose" in $$props)
      $$invalidate(0, dispose = $$new_props.dispose);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("initialized" in $$props)
      initialized = $$new_props.initialized;
    if ("publicRef" in $$props)
      $$invalidate(5, publicRef = $$new_props.publicRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*is, args*/
    192) {
      $:
        is, args, maybeSetRef();
    }
    if ($$self.$$.dirty & /*ref*/
    2) {
      $:
        $$invalidate(5, publicRef = ref);
    }
    if ($$self.$$.dirty & /*ref*/
    2) {
      $:
        refStore.set(ref);
    }
    $:
      props.updateProps(ref, $$restProps, { manualCamera: manual, pluginsProps });
    if ($$self.$$.dirty & /*ref, manual*/
    514) {
      $:
        camera.update(ref, manual);
    }
    if ($$self.$$.dirty & /*ref, makeDefault*/
    1026) {
      $:
        camera.makeDefaultCamera(ref, makeDefault);
    }
    if ($$self.$$.dirty & /*ref, $parent, attach*/
    2306) {
      $:
        attachment.update(ref, $parent, attach);
    }
    if ($$self.$$.dirty & /*ref*/
    2) {
      $:
        events.updateRef(ref);
    }
    if ($$self.$$.dirty & /*ref*/
    2) {
      $:
        plugins == null ? void 0 : plugins.updateRef(ref);
    }
    $:
      plugins == null ? void 0 : plugins.updateProps($$props);
    $:
      plugins == null ? void 0 : plugins.updateRestProps($$restProps);
  };
  $$props = exclude_internal_props($$props);
  return [
    dispose,
    ref,
    parent,
    extendsObject3D,
    isDisposableObject,
    publicRef,
    is,
    args,
    attach,
    manual,
    makeDefault,
    $parent,
    slots,
    $$scope
  ];
}
var T = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      is: 6,
      args: 7,
      attach: 8,
      manual: 9,
      makeDefault: 10,
      dispose: 0,
      ref: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "T",
      options,
      id: create_fragment4.name
    });
  }
  get is() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set is(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get args() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set args(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get attach() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attach(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get manual() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set manual(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get makeDefault() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set makeDefault(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var T_default = T;

// node_modules/@threlte/core/dist/lib/browser.js
var browser = typeof window !== "undefined";

// node_modules/@threlte/core/dist/hooks/useParentSize.js
var useParentSize = () => {
  const parentSize = writable({ width: 0, height: 0 });
  if (!browser) {
    return {
      parentSize,
      parentSizeAction: () => {
      }
    };
  }
  const mutationOptions = { childList: true, subtree: false, attributes: false };
  let el;
  const observeParent = (parent) => {
    resizeObserver.disconnect();
    mutationObserver.disconnect();
    resizeObserver.observe(parent);
    mutationObserver.observe(parent, mutationOptions);
  };
  const resizeObserver = new ResizeObserver(([entry]) => {
    const { contentRect } = entry;
    parentSize.set({
      width: contentRect.width,
      height: contentRect.height
    });
  });
  const mutationObserver = new MutationObserver((mutationsList) => {
    for (const mutation of mutationsList) {
      for (const node of mutation.removedNodes) {
        if (el === node && el.parentElement) {
          observeParent(el.parentElement);
          return;
        }
      }
    }
  });
  const parentSizeAction = (node) => {
    el = node;
    if (!el.parentElement)
      return;
    observeParent(el.parentElement);
  };
  onDestroy(() => {
    resizeObserver.disconnect();
    mutationObserver.disconnect();
  });
  return {
    parentSize,
    parentSizeAction
  };
};

// node_modules/@threlte/core/dist/lib/revision.js
var revision = Number.parseInt(REVISION.replace("dev", ""));

// node_modules/@threlte/core/dist/lib/cache.js
var shallowEqualArrays = (arrA, arrB) => {
  if (arrA === arrB)
    return true;
  if (!arrA || !arrB)
    return false;
  const len = arrA.length;
  if (arrB.length !== len)
    return false;
  for (let i = 0; i < len; i++)
    if (arrA[i] !== arrB[i])
      return false;
  return true;
};
var createCache = () => {
  setContext("threlte-cache", []);
};
var useCache = () => {
  const cache = getContext("threlte-cache");
  if (!cache) {
    throw new Error("No cache found. The cache can only be used in a child component to <Canvas>.");
  }
  const remember = (callback, keys) => {
    for (const entry2 of cache) {
      if (shallowEqualArrays(keys, entry2.keys)) {
        if (entry2.error)
          throw entry2.error;
        if (entry2.promise)
          return entry2.promise;
      }
    }
    const entry = {
      promise: callback(),
      keys,
      value: void 0
    };
    cache.push(entry);
    entry.promise.catch((error) => {
      entry.error = error;
    });
    return entry.promise;
  };
  const clear = (keys) => {
    const index = cache.findIndex((entry) => shallowEqualArrays(keys, entry.keys));
    if (index !== -1) {
      cache.splice(index, 1);
    }
  };
  return {
    remember,
    clear
  };
};

// node_modules/@threlte/core/dist/lib/getThrelteUserData.js
var getThrelteUserData = (object) => {
  return object.userData;
};

// node_modules/@threlte/core/dist/lib/storeUtils.js
var watch = (stores, callback) => {
  const d = derived(stores, (values) => {
    return values;
  });
  let cleanupFn;
  const unsubscribe = d.subscribe(async (values) => {
    if (cleanupFn)
      cleanupFn();
    const fn = await callback(values);
    if (fn)
      cleanupFn = fn;
  });
  onDestroy(() => {
    unsubscribe();
    if (cleanupFn)
      cleanupFn();
  });
};
function memoize(stores, transform) {
  const obj = {
    current: void 0
  };
  watch(stores, (v) => {
    obj.current = transform ? transform(v) : v;
  });
  return obj;
}
var currentWritable = (value) => {
  const store = writable(value);
  const extendedWritable = {
    set: (value2) => {
      extendedWritable.current = value2;
      store.set(value2);
    },
    subscribe: store.subscribe,
    update: (fn) => {
      const newValue = fn(extendedWritable.current);
      extendedWritable.current = newValue;
      store.set(newValue);
    },
    current: value
  };
  return extendedWritable;
};

// node_modules/@threlte/core/dist/lib/defaultCamera.js
var createDefaultCamera = () => {
  const defaultCamera = new PerspectiveCamera(75, 0, 0.1, 1e3);
  getThrelteUserData(defaultCamera).threlteDefaultCamera = true;
  defaultCamera.position.z = 5;
  defaultCamera.lookAt(0, 0, 0);
  return defaultCamera;
};
var setDefaultCameraAspectOnSizeChange = (ctx) => {
  watch(ctx.size, (size) => {
    if (getThrelteUserData(get_store_value(ctx.camera)).threlteDefaultCamera) {
      ctx.camera.update((c) => {
        const cam = c;
        cam.aspect = size.width / size.height;
        cam.updateProjectionMatrix();
        ctx.invalidate("Default camera: aspect ratio changed");
        return cam;
      });
    }
  });
};

// node_modules/@threlte/core/dist/lib/contexts.js
var createContexts = (options) => {
  const internalCtx = {
    debugFrameloop: options.debugFrameloop,
    frame: 0,
    frameInvalidated: true,
    invalidations: {},
    manualFrameHandlers: /* @__PURE__ */ new Set(),
    autoFrameHandlers: /* @__PURE__ */ new Set(),
    allFrameHandlers: /* @__PURE__ */ new Set(),
    allFrameHandlersNeedSortCheck: false,
    renderHandlers: /* @__PURE__ */ new Set(),
    renderHandlersNeedSortCheck: false,
    advance: false,
    dispose: async (force = false) => {
      await tick();
      if (!internalCtx.shouldDispose && !force)
        return;
      internalCtx.disposableObjects.forEach((mounted, object) => {
        var _a;
        if (mounted === 0 || force) {
          (_a = object == null ? void 0 : object.dispose) == null ? void 0 : _a.call(object);
          internalCtx.disposableObjects.delete(object);
        }
      });
      internalCtx.shouldDispose = false;
    },
    collectDisposableObjects: (object, objects) => {
      const disposables = objects ?? [];
      if (!object)
        return disposables;
      if ((object == null ? void 0 : object.dispose) && typeof object.dispose === "function" && object.type !== "Scene") {
        disposables.push(object);
      }
      Object.entries(object).forEach(([propKey, propValue]) => {
        if (propKey === "parent" || propKey === "children" || typeof propValue !== "object")
          return;
        const value = propValue;
        if (value == null ? void 0 : value.dispose) {
          internalCtx.collectDisposableObjects(value, disposables);
        }
      });
      return disposables;
    },
    addDisposableObjects: (objects) => {
      objects.forEach((obj) => {
        const currentValue = internalCtx.disposableObjects.get(obj);
        if (currentValue) {
          internalCtx.disposableObjects.set(obj, currentValue + 1);
        } else {
          internalCtx.disposableObjects.set(obj, 1);
        }
      });
    },
    removeDisposableObjects: (objects) => {
      if (objects.length === 0)
        return;
      objects.forEach((obj) => {
        const currentValue = internalCtx.disposableObjects.get(obj);
        if (currentValue && currentValue > 0) {
          internalCtx.disposableObjects.set(obj, currentValue - 1);
        }
      });
      internalCtx.shouldDispose = true;
    },
    disposableObjects: /* @__PURE__ */ new Map(),
    shouldDispose: false
  };
  const ctx = {
    size: derived([options.userSize, options.parentSize], ([uSize, pSize]) => {
      return uSize ? uSize : pSize;
    }),
    clock: new Clock(),
    camera: currentWritable(createDefaultCamera()),
    scene: new Scene(),
    renderer: void 0,
    invalidate: (debugFrameloopMessage) => {
      internalCtx.frameInvalidated = true;
      if (internalCtx.debugFrameloop && debugFrameloopMessage) {
        internalCtx.invalidations[debugFrameloopMessage] = internalCtx.invalidations[debugFrameloopMessage] ? internalCtx.invalidations[debugFrameloopMessage] + 1 : 1;
      }
    },
    advance: () => {
      internalCtx.advance = true;
    },
    colorSpace: currentWritable(options.colorSpace),
    toneMapping: currentWritable(options.toneMapping),
    dpr: currentWritable(options.dpr),
    useLegacyLights: currentWritable(options.useLegacyLights),
    shadows: currentWritable(options.shadows),
    colorManagementEnabled: currentWritable(options.colorManagementEnabled),
    frameloop: currentWritable(options.frameloop)
  };
  const userCtx = currentWritable({});
  setContext("threlte", ctx);
  setContext("threlte-internal-context", internalCtx);
  setContext("threlte-user-context", userCtx);
  const getCtx = () => ctx;
  const getInternalCtx = () => internalCtx;
  return {
    ctx,
    internalCtx,
    getCtx,
    getInternalCtx
  };
};

// node_modules/@threlte/core/dist/lib/startFrameloop.js
var runUseFrameCallbacks = (ctx, internalCtx, delta) => {
  if (internalCtx.allFrameHandlers.size === 0)
    return;
  if (internalCtx.allFrameHandlersNeedSortCheck) {
    const arr = Array.from(internalCtx.allFrameHandlers);
    const needsSort = arr.some((h) => h.order);
    if (needsSort) {
      const sorted = arr.sort((a, b) => (a.order ?? 0) > (b.order ?? 0) ? 1 : -1);
      internalCtx.allFrameHandlers.clear();
      sorted.forEach((h) => internalCtx.allFrameHandlers.add(h));
    }
    internalCtx.allFrameHandlersNeedSortCheck = false;
  }
  if (internalCtx.debugFrameloop) {
    let genericFrameHandlers = 0;
    internalCtx.autoFrameHandlers.forEach((h) => {
      if (h.debugFrameloopMessage) {
        internalCtx.invalidations[h.debugFrameloopMessage] = h.debugFrameloopMessage in internalCtx.invalidations ? internalCtx.invalidations[h.debugFrameloopMessage] + 1 : 1;
      } else {
        ++genericFrameHandlers;
      }
    });
    if (genericFrameHandlers > 0)
      internalCtx.invalidations["useFrame"] = internalCtx.autoFrameHandlers.size;
  }
  internalCtx.allFrameHandlers.forEach((h) => h.fn(ctx, delta));
};
var runUseRenderCallbacks = (ctx, internalCtx, delta) => {
  if (internalCtx.renderHandlers.size === 0)
    return;
  if (internalCtx.renderHandlersNeedSortCheck) {
    const arr = Array.from(internalCtx.renderHandlers);
    const needsSort = arr.some((h) => h.order);
    if (needsSort) {
      const sorted = arr.sort((a, b) => (a.order ?? 0) > (b.order ?? 0) ? 1 : -1);
      internalCtx.renderHandlers.clear();
      sorted.forEach((h) => internalCtx.renderHandlers.add(h));
    }
    internalCtx.renderHandlersNeedSortCheck = false;
  }
  internalCtx.renderHandlers.forEach((h) => h.fn(ctx, delta));
};
var debugFrame = (internalCtx) => {
  if (!internalCtx.debugFrameloop)
    return;
  internalCtx.frame += 1;
  console.log(`frame: ${internalCtx.frame}${Object.keys(internalCtx.invalidations).length > 0 ? ", requested by " : ""}`);
  if (Object.keys(internalCtx.invalidations).length > 0)
    console.table(internalCtx.invalidations);
  internalCtx.invalidations = {};
};
var shouldRender = (ctx, internalCtx) => {
  return ctx.frameloop.current === "always" || ctx.frameloop.current === "demand" && (internalCtx.frameInvalidated || internalCtx.autoFrameHandlers.size > 0) || ctx.frameloop.current === "never" && internalCtx.advance;
};
var startFrameloop = (ctx, internalCtx) => {
  ctx.renderer.setAnimationLoop(() => {
    internalCtx.dispose();
    const delta = ctx.clock.getDelta();
    runUseFrameCallbacks(ctx, internalCtx, delta);
    if (!shouldRender(ctx, internalCtx))
      return;
    if (internalCtx.renderHandlers.size > 0) {
      runUseRenderCallbacks(ctx, internalCtx, delta);
    } else if (ctx.camera.current) {
      ctx.renderer.render(ctx.scene, ctx.camera.current);
    }
    debugFrame(internalCtx);
    internalCtx.frameInvalidated = false;
    internalCtx.advance = false;
  });
};

// node_modules/@threlte/core/dist/lib/useRenderer.js
var colorSpaceToEncoding = {
  srgb: sRGBEncoding,
  "srgb-linear": LinearEncoding,
  "": LinearEncoding
};
var rendererHasOutputColorSpaceProperty = (renderer) => {
  return renderer.outputColorSpace !== void 0;
};
var useRenderer = (ctx) => {
  const renderer = writable(void 0);
  const createRenderer = (canvas, rendererParameters) => {
    ctx.renderer = new WebGLRenderer({
      powerPreference: "high-performance",
      canvas,
      antialias: true,
      alpha: true,
      ...rendererParameters
    });
    renderer.set(ctx.renderer);
  };
  watch([
    renderer,
    ctx.size,
    ctx.toneMapping,
    ctx.colorSpace,
    ctx.dpr,
    ctx.shadows,
    ctx.colorManagementEnabled,
    ctx.useLegacyLights
  ], ([renderer2, size, toneMapping, colorSpace, dpr, shadows, colorManagementEnabled, useLegacyLights]) => {
    if (!renderer2)
      return;
    renderer2.setSize(size.width, size.height);
    renderer2.setPixelRatio(dpr);
    if (rendererHasOutputColorSpaceProperty(renderer2)) {
      renderer2.outputColorSpace = colorSpace;
    } else {
      const encoding = colorSpaceToEncoding[colorSpace];
      if (!encoding) {
        console.warn("No encoding found for colorSpace", colorSpace);
      } else {
        renderer2.outputEncoding = encoding;
      }
    }
    renderer2.toneMapping = toneMapping;
    renderer2.shadowMap.enabled = !!shadows;
    if (shadows && shadows !== true) {
      renderer2.shadowMap.type = shadows;
    } else if (shadows === true) {
      renderer2.shadowMap.type = PCFSoftShadowMap;
    }
    const cm = ColorManagement;
    if (revision >= 150) {
      cm.enabled = colorManagementEnabled;
    } else {
      cm.legacyMode = !colorManagementEnabled;
    }
    const anyRenderer = renderer2;
    if (revision >= 150 && useLegacyLights) {
      anyRenderer.useLegacyLights = useLegacyLights;
    } else if (revision < 150) {
      anyRenderer.physicallyCorrectLights = !useLegacyLights;
    }
  });
  return {
    createRenderer
  };
};

// node_modules/@threlte/core/dist/Canvas.svelte
var file = "node_modules\\@threlte\\core\\dist\\Canvas.svelte";
function add_css(target) {
  append_styles(target, "svelte-o3oskp", "canvas.svelte-o3oskp{display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FudmFzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpSEUsb0JBQU8sQ0FDTCxPQUFPLENBQUUsS0FDWCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDYW52YXMuc3ZlbHRlIl19 */");
}
function create_if_block2(ctx) {
  let t;
  let current;
  t = new T_default({
    props: {
      is: (
        /*contexts*/
        ctx[3].ctx.scene
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = {};
      if (dirty & /*$$scope*/
      131072) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t.$set(t_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(106:2) {#if initialized}",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(107:4) <T is={contexts.ctx.scene}>",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let canvas_1;
  let parentSizeAction_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*initialized*/
    ctx[1] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      canvas_1 = element("canvas");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      canvas_1 = claim_element(nodes, "CANVAS", { class: true });
      var canvas_1_nodes = children(canvas_1);
      if (if_block)
        if_block.l(canvas_1_nodes);
      canvas_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(canvas_1, "class", "svelte-o3oskp");
      add_location(canvas_1, file, 101, 0, 2862);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, canvas_1, anchor);
      if (if_block)
        if_block.m(canvas_1, null);
      ctx[16](canvas_1);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(parentSizeAction_action = /*parentSizeAction*/
        ctx[2].call(null, canvas_1));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*initialized*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*initialized*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(canvas_1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(canvas_1);
      }
      if (if_block)
        if_block.d();
      ctx[16](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var invalidationHandlers = /* @__PURE__ */ new Set();
var invalidateGlobally = (debugFrameloopMessage) => {
  invalidationHandlers.forEach((fn) => fn(debugFrameloopMessage));
};
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Canvas", slots, ["default"]);
  let { dpr = browser ? window.devicePixelRatio : 1 } = $$props;
  let { toneMapping = ACESFilmicToneMapping } = $$props;
  let { colorSpace = "srgb" } = $$props;
  let { frameloop = "demand" } = $$props;
  let { debugFrameloop = false } = $$props;
  let { shadows = PCFSoftShadowMap } = $$props;
  let { size = void 0 } = $$props;
  let { rendererParameters = void 0 } = $$props;
  let { colorManagementEnabled = true } = $$props;
  let { useLegacyLights = revision >= 155 ? false : true } = $$props;
  let canvas;
  let initialized = false;
  const userSize = writable(size);
  const { parentSize, parentSizeAction } = useParentSize();
  const contexts = createContexts({
    colorSpace,
    toneMapping,
    dpr,
    userSize,
    parentSize,
    debugFrameloop,
    frameloop,
    shadows,
    colorManagementEnabled,
    useLegacyLights
  });
  createCache();
  const ctx = contexts.ctx;
  setDefaultCameraAspectOnSizeChange(ctx);
  invalidationHandlers.add(ctx.invalidate);
  onDestroy(() => {
    invalidationHandlers.delete(ctx.invalidate);
  });
  const { createRenderer } = useRenderer(ctx);
  onMount(() => {
    createRenderer(canvas, rendererParameters);
    startFrameloop(contexts.ctx, contexts.internalCtx);
    $$invalidate(1, initialized = true);
  });
  onDestroy(() => {
    var _a;
    contexts.internalCtx.dispose(true);
    (_a = contexts.ctx.renderer) == null ? void 0 : _a.dispose();
  });
  const writable_props = [
    "dpr",
    "toneMapping",
    "colorSpace",
    "frameloop",
    "debugFrameloop",
    "shadows",
    "size",
    "rendererParameters",
    "colorManagementEnabled",
    "useLegacyLights"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Canvas> was created with unknown prop '${key}'`);
  });
  function canvas_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      canvas = $$value;
      $$invalidate(0, canvas);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("dpr" in $$props2)
      $$invalidate(4, dpr = $$props2.dpr);
    if ("toneMapping" in $$props2)
      $$invalidate(5, toneMapping = $$props2.toneMapping);
    if ("colorSpace" in $$props2)
      $$invalidate(6, colorSpace = $$props2.colorSpace);
    if ("frameloop" in $$props2)
      $$invalidate(7, frameloop = $$props2.frameloop);
    if ("debugFrameloop" in $$props2)
      $$invalidate(8, debugFrameloop = $$props2.debugFrameloop);
    if ("shadows" in $$props2)
      $$invalidate(9, shadows = $$props2.shadows);
    if ("size" in $$props2)
      $$invalidate(10, size = $$props2.size);
    if ("rendererParameters" in $$props2)
      $$invalidate(11, rendererParameters = $$props2.rendererParameters);
    if ("colorManagementEnabled" in $$props2)
      $$invalidate(12, colorManagementEnabled = $$props2.colorManagementEnabled);
    if ("useLegacyLights" in $$props2)
      $$invalidate(13, useLegacyLights = $$props2.useLegacyLights);
    if ("$$scope" in $$props2)
      $$invalidate(17, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    invalidationHandlers,
    invalidateGlobally,
    onDestroy,
    onMount,
    writable,
    ACESFilmicToneMapping,
    PCFSoftShadowMap,
    T: T_default,
    useParentSize,
    browser,
    revision,
    createCache,
    createContexts,
    setDefaultCameraAspectOnSizeChange,
    startFrameloop,
    useRenderer,
    dpr,
    toneMapping,
    colorSpace,
    frameloop,
    debugFrameloop,
    shadows,
    size,
    rendererParameters,
    colorManagementEnabled,
    useLegacyLights,
    canvas,
    initialized,
    userSize,
    parentSize,
    parentSizeAction,
    contexts,
    ctx,
    createRenderer
  });
  $$self.$inject_state = ($$props2) => {
    if ("dpr" in $$props2)
      $$invalidate(4, dpr = $$props2.dpr);
    if ("toneMapping" in $$props2)
      $$invalidate(5, toneMapping = $$props2.toneMapping);
    if ("colorSpace" in $$props2)
      $$invalidate(6, colorSpace = $$props2.colorSpace);
    if ("frameloop" in $$props2)
      $$invalidate(7, frameloop = $$props2.frameloop);
    if ("debugFrameloop" in $$props2)
      $$invalidate(8, debugFrameloop = $$props2.debugFrameloop);
    if ("shadows" in $$props2)
      $$invalidate(9, shadows = $$props2.shadows);
    if ("size" in $$props2)
      $$invalidate(10, size = $$props2.size);
    if ("rendererParameters" in $$props2)
      $$invalidate(11, rendererParameters = $$props2.rendererParameters);
    if ("colorManagementEnabled" in $$props2)
      $$invalidate(12, colorManagementEnabled = $$props2.colorManagementEnabled);
    if ("useLegacyLights" in $$props2)
      $$invalidate(13, useLegacyLights = $$props2.useLegacyLights);
    if ("canvas" in $$props2)
      $$invalidate(0, canvas = $$props2.canvas);
    if ("initialized" in $$props2)
      $$invalidate(1, initialized = $$props2.initialized);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*size*/
    1024) {
      $:
        userSize.set(size);
    }
  };
  return [
    canvas,
    initialized,
    parentSizeAction,
    contexts,
    dpr,
    toneMapping,
    colorSpace,
    frameloop,
    debugFrameloop,
    shadows,
    size,
    rendererParameters,
    colorManagementEnabled,
    useLegacyLights,
    ctx,
    slots,
    canvas_1_binding,
    $$scope
  ];
}
var Canvas = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        dpr: 4,
        toneMapping: 5,
        colorSpace: 6,
        frameloop: 7,
        debugFrameloop: 8,
        shadows: 9,
        size: 10,
        rendererParameters: 11,
        colorManagementEnabled: 12,
        useLegacyLights: 13,
        ctx: 14
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Canvas",
      options,
      id: create_fragment5.name
    });
  }
  get dpr() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dpr(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toneMapping() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toneMapping(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorSpace() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorSpace(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frameloop() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frameloop(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get debugFrameloop() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set debugFrameloop(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadows() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadows(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rendererParameters() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rendererParameters(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorManagementEnabled() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorManagementEnabled(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useLegacyLights() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useLegacyLights(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ctx() {
    return this.$$.ctx[14];
  }
  set ctx(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Canvas_default = Canvas;

// node_modules/@threlte/core/dist/components/T/T.js
var catalogue = {};
var extend = (extensions) => {
  Object.assign(catalogue, extensions);
};
var augmentConstructorArgs = (args, is) => {
  const module = catalogue[is] || three_module_exports[is];
  if (!module) {
    throw new Error(`No Three.js module found for ${is}. Did you forget to extend the catalogue?`);
  }
  return {
    ...args,
    props: {
      ...args.props,
      is: module
    }
  };
};
var proxyTConstructor = (is) => {
  return new Proxy(class {
  }, {
    construct(_, [args]) {
      const castedArgs = args;
      return new T_default(augmentConstructorArgs(castedArgs, is));
    }
  });
};
var T2 = new Proxy(class {
}, {
  construct(_, [args]) {
    const castedArgs = args;
    return new T_default(castedArgs);
  },
  get(_, is) {
    return proxyTConstructor(is);
  }
});

// node_modules/@threlte/core/dist/plugins/injectPlugin.js
function injectPlugin(nameOrNamedPlugin, maybePlugin) {
  const contextName2 = "threlte-plugin-context";
  if (Array.isArray(nameOrNamedPlugin)) {
    const [name, plugin] = nameOrNamedPlugin;
    setContext(contextName2, {
      ...getContext(contextName2),
      [name]: plugin
    });
  } else {
    const name = nameOrNamedPlugin;
    const plugin = maybePlugin;
    if (!plugin)
      return;
    setContext(contextName2, {
      ...getContext(contextName2),
      [name]: plugin
    });
  }
}

// node_modules/@threlte/core/dist/plugins/createPlugin.js
function createPlugin(name, plugin) {
  return [name, plugin];
}

// node_modules/@threlte/core/dist/hooks/useFrame.js
var useFrame = (fn, options) => {
  if (!browser) {
    return {
      start: () => void 0,
      stop: () => void 0,
      started: readable(false)
    };
  }
  const renderCtx = getContext("threlte-internal-context");
  if (renderCtx === void 0) {
    throw new Error("No Threlte context found, are you using this hook inside of <Canvas>?");
  }
  const invalidate = (options == null ? void 0 : options.invalidate) ?? true;
  const handler = {
    fn,
    order: options == null ? void 0 : options.order,
    debugFrameloopMessage: options == null ? void 0 : options.debugFrameloopMessage,
    invalidate
  };
  const started = writable(false);
  const stop = () => {
    if (invalidate) {
      renderCtx.autoFrameHandlers.delete(handler);
    } else {
      renderCtx.manualFrameHandlers.delete(handler);
    }
    renderCtx.allFrameHandlers.delete(handler);
    started.set(false);
  };
  const start = () => {
    if (invalidate) {
      renderCtx.autoFrameHandlers.add(handler);
    } else {
      renderCtx.manualFrameHandlers.add(handler);
    }
    renderCtx.allFrameHandlers.add(handler);
    renderCtx.allFrameHandlersNeedSortCheck = true;
    started.set(true);
  };
  if ((options == null ? void 0 : options.autostart) ?? true) {
    start();
  }
  onDestroy(() => {
    stop();
  });
  return {
    start,
    stop,
    started: {
      subscribe: started.subscribe
    }
  };
};

// node_modules/@threlte/core/dist/hooks/useRender.js
var useRender = (fn, options) => {
  if (!browser) {
    return;
  }
  const renderCtx = getContext("threlte-internal-context");
  if (renderCtx === void 0) {
    throw new Error("No Threlte context found, are you using this hook inside of <Canvas>?");
  }
  const handler = {
    fn,
    order: options == null ? void 0 : options.order
  };
  renderCtx.renderHandlers.add(handler);
  renderCtx.renderHandlersNeedSortCheck = true;
  onDestroy(() => {
    renderCtx.renderHandlers.delete(handler);
  });
};

// node_modules/@threlte/core/dist/hooks/useThrelteUserContext.js
function useThrelteUserContext(namespace, value, options) {
  const userCtxStore = getContext("threlte-user-context");
  if (!userCtxStore) {
    throw new Error("No user context store found, did you invoke this function outside of your main <Canvas> component?");
  }
  if (!namespace) {
    return {
      subscribe: userCtxStore.subscribe
    };
  }
  if (namespace && !value) {
    return derived(userCtxStore, (ctx) => ctx[namespace]);
  }
  userCtxStore.update((ctx) => {
    if (namespace in ctx) {
      if (!options || options.existing === "skip")
        return ctx;
      if (options.existing === "merge") {
        Object.assign(ctx[namespace], value);
        return ctx;
      }
    }
    ctx[namespace] = value;
    return ctx;
  });
  return userCtxStore.current[namespace];
}

// node_modules/@threlte/core/dist/lib/asyncWritable.js
var asyncWritable = (promise) => {
  const store = writable(void 0);
  const error = writable(void 0);
  promise.then((result) => {
    store.set(result);
  }).catch((e) => {
    console.error("Error in asyncWritable:", e.message);
    error.set(e);
  });
  return Object.assign(Object.assign(promise, store), { error, promise });
};

// node_modules/@threlte/core/dist/hooks/useLoader.js
var useLoader = (Proto, options = {}) => {
  var _a;
  const { remember, clear: clearCacheItem } = useCache();
  const loader = new Proto();
  (_a = options.extend) == null ? void 0 : _a.call(options, loader);
  const load = (input, options2) => {
    if (Array.isArray(input)) {
      const promises = input.map((url) => {
        return remember(async () => {
          var _a2;
          const result = await loader.loadAsync(url, options2 == null ? void 0 : options2.onProgress);
          return ((_a2 = options2 == null ? void 0 : options2.transform) == null ? void 0 : _a2.call(options2, result)) ?? result;
        }, [Proto, url]);
      });
      const store = asyncWritable(Promise.all(promises));
      return store;
    } else if (typeof input === "string") {
      const promise = remember(async () => {
        var _a2;
        const result = await loader.loadAsync(input, options2 == null ? void 0 : options2.onProgress);
        return ((_a2 = options2 == null ? void 0 : options2.transform) == null ? void 0 : _a2.call(options2, result)) ?? result;
      }, [Proto, input]);
      const store = asyncWritable(promise);
      return store;
    } else {
      const promises = Object.values(input).map((url) => {
        return remember(async () => {
          var _a2;
          const result = await loader.loadAsync(url, options2 == null ? void 0 : options2.onProgress);
          return ((_a2 = options2 == null ? void 0 : options2.transform) == null ? void 0 : _a2.call(options2, result)) ?? result;
        }, [Proto, url]);
      });
      const store = asyncWritable(Promise.all(promises).then((results) => {
        return Object.fromEntries(Object.entries(input).map(([key], i) => [key, results[i]]));
      }));
      return store;
    }
  };
  const clear = (input) => {
    if (Array.isArray(input)) {
      input.forEach((url) => {
        clearCacheItem([Proto, url]);
      });
    } else if (typeof input === "string") {
      clearCacheItem([Proto, input]);
    } else {
      Object.entries(input).forEach(([key, url]) => {
        clearCacheItem([Proto, key, url]);
      });
    }
  };
  return {
    load,
    clear,
    loader
  };
};

// node_modules/@threlte/core/dist/lib/forwardEventHandlers.js
var forwardEventHandlers = () => {
  const component = get_current_component();
  const dispatchingComponent = writable(void 0);
  watch(dispatchingComponent, (dispatchingComponent2) => {
    if (!dispatchingComponent2)
      return;
    Object.entries(component.$$.callbacks).forEach((callback) => {
      const [key, value] = callback;
      if (key in dispatchingComponent2.$$.callbacks && Array.isArray(dispatchingComponent2.$$.callbacks[key])) {
        dispatchingComponent2.$$.callbacks[key].push(...value);
      } else {
        dispatchingComponent2.$$.callbacks[key] = value;
      }
    });
  });
  return dispatchingComponent;
};

export {
  DisposableObject_default,
  createObjectStore,
  useThrelte,
  useParent,
  HierarchicalObject_default,
  SceneGraphObject_default,
  resolvePropertyPath,
  createRawEventDispatcher,
  useCache,
  watch,
  memoize,
  currentWritable,
  Canvas_default,
  extend,
  T2 as T,
  injectPlugin,
  createPlugin,
  useFrame,
  useRender,
  useThrelteUserContext,
  asyncWritable,
  useLoader,
  forwardEventHandlers
};
//# sourceMappingURL=chunk-YAVIW32N.js.map
